import {
  GetObjectCommand,
  PutObjectCommand,
  S3Client,
} from "@aws-sdk/client-s3";
import { basename } from "path/posix";
import { stringify } from "csv-stringify/sync";
import { createHtmlReport } from "./create-html-report.ts";

interface InvokeEvent {
  rcloneResultsLarge: {
    manifestBucket: string;
    manifestKey: string;
  };
  rcloneResultsSmall: {
    manifestBucket: string;
    manifestKey: string;
  };
  rcloneResultsNeedThawSmall: {
    manifestBucket: string;
    manifestKey: string;
  };
  rcloneResultsNeedThawLarge: {
    manifestBucket: string;
    manifestKey: string;
  };
  destinationBucket: string;
  destinationPrefixKey: string;
  destinationEndCopyRelativeKey: string;
  workingBucket: string;
  generateCopyReport?: boolean;
}

type TransferStatus = "ERROR" | "ALREADYCOPIED" | "COPIED";

interface FileResult {
  name: string;
  status: TransferStatus;
  speed: number;
  message: string | number;
  destination: string;
  bytesTransferred: number;
  elapsedSeconds: number;
  // source: string;
  // copyMode: string;
}
/**
 * A handler that process the Steps CSV result (which should have a bunch
 * of rclone stats) - and converts that into a CSV report for the
 * copy out destination.
 *
 * @param event
 */
export async function handler(event: InvokeEvent) {
  // debug input event
  console.debug(JSON.stringify(event, null, 2));

  const client = new S3Client({});

  // the manifest.json is generated by an AWS Steps DISTRIBUTED map and shows the results
  // of all the individual map run parts
  const getManifestCommand = new GetObjectCommand({
    Bucket: event.workingBucket,
    Key: event.rcloneResultsLarge.manifestKey,
  });

  const getManifestResult = await client.send(getManifestCommand);
  if (!getManifestResult.Body) {
    throw new Error("Manifest S3 object Body is undefined");
  }
  const getManifestContent = await getManifestResult.Body.transformToString();

  // A sample manifest
  // {"DestinationBucket":"elsa-data-tmp",
  // "MapRunArn":"arn:aws:states:ap-southeast-2:12345678:mapRun:CopyOutStateMachineABCD/4474d22f-4056-30e3-978c-027016edac90:0c17ffd6-e8ad-44c0-a65b-a8b721007241",
  // "ResultFiles":{
  //     "FAILED":[],
  //     "PENDING":[],
  //     "SUCCEEDED":[{"Key":"copy-out-test-working/a6faea86c066cd90/1-objects-to-copy.tsv/0c17ffd6-e8ad-44c0-a65b-a8b721007241/SUCCEEDED_0.json",
  //                   "Size":2887}]}}

  const manifest = JSON.parse(getManifestContent);

  console.debug(JSON.stringify(manifest, null, 2));

  const resultFiles = manifest["ResultFiles"];

  if (!resultFiles)
    throw new Error(
      "AWS Steps Distributed map manifest.json is missing ResultFiles",
    );

  const pendingFiles = resultFiles["PENDING"];
  const failedFiles = resultFiles["FAILED"];
  const succeededFiles = resultFiles["SUCCEEDED"];

  // Validate manifest shape: all three status buckets must be arrays.
  if (
    !Array.isArray(pendingFiles) ||
    !Array.isArray(failedFiles) ||
    !Array.isArray(succeededFiles)
  )
    throw new Error(
      "AWS Steps Distributed map manifest.json is missing an expected array for PENDING, FAILED or SUCCEEDED",
    );

  // Fail fast if any work is still pending. By the time this Lambda runs,
  // the Distributed Map should have fully completed (no partial results).
  if (pendingFiles.length > 0)
    throw new Error(
      "AWS Steps Distributed map manifest.json indicates there are PENDING results which is not a state we are expecting",
    );

  // This Lambda is only expected to be run when the copy has fully succeeded.
  // Maybe in future we want to handle partial success.
  if (failedFiles.length > 0)
    throw new Error("Copy is meant to succeed - but it had failed results");

  const fileResults: Record<string, FileResult> = {};

  for (const succeededFile of succeededFiles) {
    const getSuccessCommand = new GetObjectCommand({
      Bucket: event.workingBucket,
      Key: succeededFile["Key"],
    });

    const getSuccessResult = await client.send(getSuccessCommand);
    if (!getSuccessResult.Body) {
      throw new Error("Success S3 object Body is undefined");
    }

    const getSuccessContent = await getSuccessResult.Body.transformToString();

    const content = getSuccessContent.trim();
    const rows = content.startsWith("[")
      ? JSON.parse(content)
      : JSON.parse(
          `[${content
            .split(/\r?\n/)
            .filter((l) => l.trim())
            .join(",")}]`,
        );

    for (const row of rows) {
      // NOTE/WARNING: this behaviour is very dependent on rclone and our interpretation
      // of rclone stats - so if things start breaking this is where I would start
      // looking

      const source = row["source"];
      // The name is the basename of the source..

      // Original values
      // const errors: number = rcloneRow["errors"];
      // const lastError: number = rcloneRow["lastError"];
      // const serverSideCopyBytes: number = rcloneRow["serverSideCopyBytes"];
      // const elapsedTime = rcloneRow["elapsedTime"];
      // const totalTransfers = rcloneRow["totalTransfers"];
      // const retryError = rcloneRow["retryError"];

      // Debbuged

      // Is there were any errors during the transfer ?
      const errors: number = row["errors"] ?? 0;

      const name = basename(source);

      // Compute the transfer speed
      const elapsedSeconds = row["elapsedSeconds"] ?? 0;
      const bytesTransferred = row["bytesTransferred"] ?? 0;
      const speedMiBps =
        elapsedSeconds > 0
          ? bytesTransferred / elapsedSeconds / 1024 / 1024
          : 0;

      const destination = row["destination"];
      const lastError: number = row["lastError"];
      const retryError = row["retryError"]; // Not being passed

      // firstly if we have been signalled an error - we need to report that
      if (errors > 0) {
        fileResults[name] = {
          name: name,
          status: "ERROR",
          speed: speedMiBps,
          message: lastError,
          destination: destination,
          bytesTransferred: bytesTransferred,
          elapsedSeconds: elapsedSeconds,
        };
      } else {
        // if we didn't end up transferring anything BUT there was no actual error AND
        // we did a retry - then that probably means the source file didn't exist
        if (bytesTransferred < 1 && retryError) {
          fileResults[name] = {
            name: name,
            status: "ERROR",
            speed: speedMiBps,
            message: "source file did not exist so nothing was transferred",
            destination: destination,
            bytesTransferred: bytesTransferred,
            elapsedSeconds: elapsedSeconds,
          };
        }
        // if we didn't end up transferring anything BUT there was no actual error
        // AND we didn't do any retries then changes are we skipped due to it already
        // being at the destination
        else if (bytesTransferred < 1 && !retryError) {
          fileResults[name] = {
            name: name,
            status: "ALREADYCOPIED",
            speed: speedMiBps,
            message:
              "destination file already exists with same checksum so nothing was transferred",
            destination: destination,
            bytesTransferred: bytesTransferred,
            elapsedSeconds: elapsedSeconds,
          };
        } else {
          fileResults[name] = {
            name: name,
            status: "COPIED",
            speed: speedMiBps,
            message: "",
            destination: destination,
            bytesTransferred: bytesTransferred,
            elapsedSeconds: elapsedSeconds,
          };
        }
      }
    }

    // debug results before we make the CSV
    console.debug(JSON.stringify(fileResults, null, 2));

    const output = stringify(Object.values(fileResults), {
      header: true,
      columns: {
        name: "OBJECTNAME",
        status: "TRANSFERSTATUS",
        speed: "MBPERSEC",
        message: "MESSAGE",
        destination: "DESTINATION",
        bytesTransferred: "BYTESTRANSFERRED",
        elapsedSeconds: "ELAPSEDSECONDS",
        // source: "SOURCE",
        // copyMode: "COPYMODE",
      },
    });

    const putCommand = new PutObjectCommand({
      Bucket: event.destinationBucket,
      Key: `${event.destinationPrefixKey}${event.destinationEndCopyRelativeKey}`,
      Body: output,
    });

    // Generate HTML report if requested

    if (event.generateCopyReport) {
      // We uses this key by now for simplicitym, but we sould use a dedicated key for the HTML report.
      const csvKey = `${event.destinationPrefixKey}${event.destinationEndCopyRelativeKey}`;
      const htmlKey = csvKey.replace("ENDED_COPY.csv", "copy_report.html");

      // Build HTML
      const html = createHtmlReport({
        title: "Copy Results Report",
        records: Object.values(fileResults) as FileResult[],
        destinationBucket: event.destinationBucket,
        destinationFolderKey: event.destinationPrefixKey,
      });
      // Save the HTML report
      await client.send(
        new PutObjectCommand({
          Bucket: event.destinationBucket,
          Key: htmlKey,
          Body: html,
          ContentType: "text/html; charset=utf-8",
        }),
      );
    }

    await client.send(putCommand);
    return output;
  }
}
