import {
  GetObjectCommand,
  PutObjectCommand,
  S3Client,
} from "@aws-sdk/client-s3";
import { basename } from "path/posix";
import { stringify } from "csv-stringify/sync";
import { env } from "node:process";

interface InvokeEvent {
  rcloneResultsLarge: {
    manifestBucket: string;
    manifestKey: string;
  };
  rcloneResultsSmall: {
    manifestBucket: string;
    manifestKey: string;
  };
  destinationBucket: string;
  destinationPrefixKey: string;
  destinationEndCopyRelativeKey: string;
}

/**
 * A handler that process the Steps CSV result (which should have a bunch
 * of rclone stats) - and converts that into a CSV report for the
 * copy out destination.
 *
 * @param event
 */
export async function handler(event: InvokeEvent) {
  // debug input event
  console.debug(JSON.stringify(event, null, 2));

  const client = new S3Client({});

  // the manifest.json is generated by an AWS Steps DISTRIBUTED map and shows the results
  // of all the individual map run parts
  const getManifestCommand = new GetObjectCommand({
    Bucket: event.rcloneResultsLarge.manifestBucket,
    Key: event.rcloneResultsLarge.manifestKey,
  });

  const getManifestResult = await client.send(getManifestCommand);

  const getManifestContent = await getManifestResult.Body.transformToString();

  // A sample manifest
  // {"DestinationBucket":"elsa-data-tmp",
  // "MapRunArn":"arn:aws:states:ap-southeast-2:12345678:mapRun:CopyOutStateMachineABCD/4474d22f-4056-30e3-978c-027016edac90:0c17ffd6-e8ad-44c0-a65b-a8b721007241",
  // "ResultFiles":{
  //     "FAILED":[],
  //     "PENDING":[],
  //     "SUCCEEDED":[{"Key":"copy-out-test-working/a6faea86c066cd90/1-objects-to-copy.tsv/0c17ffd6-e8ad-44c0-a65b-a8b721007241/SUCCEEDED_0.json",
  //                   "Size":2887}]}}

  const manifest = JSON.parse(getManifestContent);

  console.debug(JSON.stringify(manifest, null, 2));

  const rf = manifest["ResultFiles"];

  if (!rf)
    throw new Error(
      "AWS Steps Distributed map manifest.json is missing ResultFiles",
    );

  const pending = rf["PENDING"];
  const failed = rf["FAILED"];
  const succeeded = rf["SUCCEEDED"];

  if (
    !Array.isArray(pending) ||
    !Array.isArray(failed) ||
    !Array.isArray(succeeded)
  )
    throw new Error(
      "AWS Steps Distributed map manifest.json is missing an expected array for PENDING, FAILED or SUCCEEDED",
    );

  if (pending.length > 0)
    throw new Error(
      "AWS Steps Distributed map manifest.json indicates there are PENDING results which is not a state we are expecting",
    );

  if (failed.length > 0)
    throw new Error("Copy is meant to succeed - but it had failed results");

  const fileResults = {};

  for (const s of succeeded) {
    const getSuccessCommand = new GetObjectCommand({
      Bucket: event.rcloneResultsLarge.manifestBucket,
      Key: s["Key"],
    });

    const getSuccessResult = await client.send(getSuccessCommand);
    const getSuccessContent = await getSuccessResult.Body.transformToString();

    return getSuccessContent;

    for (const row of JSON.parse(getSuccessContent)) {
      if (row["Output"]) {
        const rowOutput = JSON.parse(row["Output"]);

        //  { "bytes": 0,
        //  "checks": 0,
        //  "deletedDirs": 0,
        //  "deletes": 0,
        //  "elapsedTime": 0.2928195,
        //  "errors": 0,
        //  "eta": null,
        //  "fatalError": false,
        //  "renames": 0,
        //  "retryError": false,
        //  "serverSideCopies": 1,
        //  "serverSideCopyBytes": 9,
        //  "serverSideMoveBytes": 0,
        //  "serverSideMoves": 0,
        //  "source": "s3:elsa-data-tmp/copy-out-test-objects/d76848c9ae316e13/1-src/1.bin",
        //  "speed": 0,
        //  "totalBytes": 0,
        //  "totalChecks": 0,
        //  "totalTransfers": 1,
        //  "transferTime": 0.046778609,
        //  "transfers": 1 }
        for (const rcloneRow of rowOutput["rcloneResult"]) {
          console.log(JSON.stringify(rcloneRow, null, 2));

          const s = rcloneRow["source"];
          const b = basename(s);

          // NOTE/WARNING: this behaviour is very dependent on rclone and our interpretation
          // of rclone stats - so if things start breaking this is where I would start
          // looking
          const errors: number = rcloneRow["errors"];
          const lastError: number = rcloneRow["lastError"];
          const serverSideCopyBytes: number = rcloneRow["serverSideCopyBytes"];
          const elapsedTime = rcloneRow["elapsedTime"];
          const totalTransfers = rcloneRow["totalTransfers"];
          const retryError = rcloneRow["retryError"];

          // firstly if we have been signalled an error - we need to report that
          if (errors > 0) {
            fileResults[b] = {
              name: b,
              status: "ERROR",
              speed: 0,
              message: lastError,
            };
          } else {
            // if we didn't end up transferring anything BUT there was no actual error AND
            // we did a retry - then that probably means the source file didn't exist
            if (totalTransfers < 1 && retryError) {
              fileResults[b] = {
                name: b,
                status: "ERROR",
                speed: 0,
                message: "source file did not exist so nothing was transferred",
              };
            }
            // if we didn't end up transferring anything BUT there was no actual error
            // AND we didn't do any retries then changes are we skipped due to it already
            // being at the destination
            else if (totalTransfers < 1 && !retryError) {
              fileResults[b] = {
                name: b,
                status: "ALREADYCOPIED",
                speed: 0,
                message:
                  "destination file already exists with same checksum so nothing was transferred",
              };
            } else {
              // if we did do a copy then copySeconds will normally be a value and we can compute a speed
              if (elapsedTime)
                fileResults[b] = {
                  name: b,
                  status: "COPIED",
                  speed: Math.floor(
                    serverSideCopyBytes / elapsedTime / 1024 / 1024,
                  ),
                  message: "",
                };
            }
          }
        }
      }
    }

    // debug results before we make the CSV
    console.debug(JSON.stringify(fileResults, null, 2));

    const output = stringify(Object.values(fileResults), {
      header: true,
      columns: {
        name: "OBJECTNAME",
        status: "TRANSFERSTATUS",
        speed: "MBPERSEC",
        message: "MESSAGE",
      },
    });

    return output;

    const putCommand = new PutObjectCommand({
      Bucket: event.destinationBucket,
      Key: `${event.destinationPrefixKey}${event.destinationEndCopyRelativeKey}`,
      Body: output,
    });

    await client.send(putCommand);
  }
}
