import {
  Chain,
  IChainable,
  INextable,
  JsonPath,
  State,
  StateGraph,
  StateMachine,
} from "aws-cdk-lib/aws-stepfunctions";
import {
  Effect,
  ManagedPolicy,
  Policy,
  PolicyStatement,
} from "aws-cdk-lib/aws-iam";
import { Construct } from "constructs";

export interface S3JsonlDistributedMapProps {
  readonly iterator: State;
  readonly toleratedFailurePercentage: number;
  readonly itemReader: {
    readonly Bucket?: JsonPath | string;
    readonly "Bucket.$"?: string;
    readonly Key?: JsonPath | string;
    readonly "Key.$"?: string;
  };
  readonly resultWriter?: {
    readonly Bucket?: JsonPath | string;
    readonly "Bucket.$"?: string;
    readonly Prefix?: JsonPath | string;
    readonly "Prefix.$"?: string;
  };
  readonly itemSelector?: Readonly<Record<string, JsonPath | string>>;

  readonly batchMaxItems?: number;
  readonly batchMaxItemsPath?: JsonPath | string;
  readonly batchInput?: Readonly<Record<string, JsonPath | string>>;

  readonly maxConcurrency?: number;
  readonly maxConcurrencyPath?: JsonPath | string;

  readonly inputPath?: JsonPath | string;

  readonly resultPath?: JsonPath | string;
  readonly resultSelector?: Readonly<Record<string, JsonPath | string>>;

  readonly assign?: Readonly<Record<string, JsonPath | string>>;

  readonly label?: string;
}

export class S3JsonlDistributedMap
  extends State
  implements IChainable, INextable
{
  public readonly endStates: INextable[];
  private readonly props: S3JsonlDistributedMapProps;

  private readonly graph: StateGraph;
  private readonly policy: Policy;

  constructor(scope: Construct, id: string, props: S3JsonlDistributedMapProps) {
    super(scope, id, {});
    this.props = props;

    if (props.batchMaxItems && props.batchMaxItemsPath)
      throw Error("Only one of batchMaxItems or batchMaxItemsPath can be set");

    if (props.maxConcurrency && props.maxConcurrencyPath)
      throw Error(
        "Only one of maxConcurrency or maxConcurrencyPath can be set",
      );

    this.graph = new StateGraph(props.iterator, `Map ${this.stateId} Iterator`);
    this.policy = new Policy(this, "IamRole");

    this.endStates = [this];
  }

  grantNestedPermissions(stateMachine: StateMachine) {
    // this grants the autogenerated permissions in the distributed maps substates to the state machine
    // (e.g) dynamodb, lambda invoke, etc
    this.graph.policyStatements.forEach((s) => stateMachine.addToRolePolicy(s));

    // this grants the permissions to the state machine to start, stop, and describe the map
    // NB: we can't add the statement directly to the state machine or it creates a circular
    // reference which the CDK objects too.  By using a policy we get around this limitation.

    this.policy.addStatements(
      new PolicyStatement({
        effect: Effect.ALLOW,
        actions: [
          "states:StartExecution",
          "states:DescribeExecution",
          "states:StopExecution",
        ],
        resources: [stateMachine.stateMachineArn],
      }),
    );

    this.policy.attachToRole(stateMachine.role);

    stateMachine.role.addManagedPolicy(
      ManagedPolicy.fromAwsManagedPolicyName("AmazonS3FullAccess"),
    );
  }

  protected makeNext(next: State) {
    super.makeNext(next);
    next.bindToGraph(this.graph);
  }

  public next(next: IChainable): Chain {
    super.makeNext(next.startState);
    return Chain.sequence(this, next);
  }

  override toStateJson(): object {
    // if any of these are specified we want to put in an ItemBatcher
    // block which will tell the DISTRIBUTED map to switch on batching
    const useBatching =
      !!this.props.batchMaxItemsPath ||
      !!this.props.batchMaxItems ||
      !!this.props.batchInput;

    const stateJson = {
      Type: "Map",
      QueryLanguage: "JSONPath",
      ToleratedFailurePercentage: this.props.toleratedFailurePercentage,
      ItemProcessor: {
        ProcessorConfig: {
          Mode: "DISTRIBUTED",
          ExecutionType: "STANDARD",
        },
        ...this.graph.toGraphJson(),
      },
      ItemReader: {
        Resource: "arn:aws:states:::s3:getObject",
        ReaderConfig: {
          InputType: "JSONL",
        },
        Parameters: this.props.itemReader,
      },
      ItemSelector: this.props.itemSelector,
      ItemBatcher: useBatching
        ? {
            MaxItemsPerBatch: this.props.batchMaxItems,
            MaxItemsPerBatchPath: this.props.batchMaxItemsPath,
            BatchInput: this.props.batchInput,
          }
        : undefined,
      MaxConcurrency: this.props.maxConcurrency,
      MaxConcurrencyPath: this.props.maxConcurrencyPath,
      Label: this.props.label,
      ResultWriter: this.props.resultWriter
        ? {
            Resource: "arn:aws:states:::s3:putObject",
            Parameters: this.props.resultWriter,
            WriterConfig: {
              Transformation: "FLATTEN",
              OutputType: "JSONL",
            },
          }
        : undefined,
      Assign: this.props.assign,
      InputPath: this.props.inputPath,
      ResultPath: this.props.resultPath,
      ResultSelector: this.props.resultSelector,
    };

    return {
      ...this.renderNextEnd(),
      ...stateJson,
    };
  }
}
